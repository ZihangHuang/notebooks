一、工作中遇到一个难题：
回答：
原本是 PC 页面，要自适应移动端，主要是表格的自适应。
因为 PC 和移动端的 UI 交互不一样，例如表格内容在 PC 端是横向展示，移动端因为设备宽度小，是纵向展示的，之前的做法都是各写一套，不同端展示不同的组件去展示。后面觉得每次开发都要写两套的成本太高了，于是想实现只需要写 PC 端的内容，在移动端则按照统一的 UI，根据 PC 的内容，自动适配成移动端的 UI（例如内容纵向排列、操作按钮固定在尾行等）
思路：
1、基于 el-table 封装一个表格组件 mp-table，提供一个 isMobile 的 prop 参数，这个值可以通过判断设备宽度，或者其他业务场景来获得。
mp-table 使用方式与 el-table 一样，只是把外层 el-table 替换成 mp-table，内层表格内容还是使用 el-table-column 正常写。mp-table 组件内部会去收集传入 el-table-column，整理成一个节点数组，如果 el-table-column 使用了插槽去自定义内容，则再收集它的$scopedSlots。然后把这个节点数组传递给一个专门展示移动端 UI 的组件，它会去遍历这个数组，通过函数化组件把在 PC 端定义好的内容，修改成移动端的布局和尺寸，同时会保持内容（el-table-column 的插槽）不变。
有时候 PC 和移动的内容会有些差异，例如只想在移动端展示部分重要的字段，则可以通过给 el-table-column 传给一个字段，在遍历展示节点数组内容时，会过滤掉不展示的内容，然后自动插入一个展示全部的按钮，以及一个使用 Vue.extend 创建的全局弹窗。当点击按钮是，会遍历所有的节点数据，展示全部字段内容。
2、该组件还支持通过传递 json 配置来开发，而不使用 el-table-column，进一步提高开发效率。

二、组件库问题

工作中使用到两个组件库，一个是把 element-ui 的仓库 folk 下来魔改，例如 el-table 原有的合计行是在最底行，我们改成了在表头下第一行，还有表头滚动时粘性悬浮在顶部等。还新增一些自定义的组件，例如图标组件、移动端下使用的组件（输入框、时间选择等）。
另外一个是基于 element-ui 的二次封装组件库，是偏向业务层面的，例如有个 Search 组件，包含了输入框、选择器、复选框等，可以通过传入 json 配置，基于统一的 UI，快速生成表格筛选项。

三、react 状态管理

1、最开始使用 redux，但是太繁琐了。

2、也使用过 mobx，但总感觉在使用 vuex 一样。

3、现在简单的状态管理，使用的是 useReducer 和 context。
具体实现：使用 React.createContext 创建一个 context 作为 store，组件最外层使用 context.Provider，设定好 reducer 函数，传入给 useReducer 拿到 state 和 dispath，传递给 Provider 的 value 值，子组件就可以使用 useContext 获取到 state 和 dispatch 来操作 store。
同时约定 dispatch 只发送 action 和 payload，然后 action 和 payload 被传入 reducer 函数，返回一个新的 state，实现类似 redux 的流程。
优点：简单、无需引入其他库。
缺点：

- 采用单一数据源，所有状态存储在一个 state 中，当某些状态不再需要使用时，也不会被垃圾回收释放内存。
- 直接使用的话，会有一定的性能问题：每一次对 state 的某个值变更，都会导致其他使用该 state 的组件 re-render，即使没有使用该值。  可以通过 useMemo 来解决这个问题，但是就需要一定的成本来。

4、复杂则使用 Recoil：atom、selector、useRecoilState 等。Recoil 的状态定义是增量和分布式的，增量意味着我们可以在用的时候再定义新的状态，而不必将所有状态提前定义好再消费。分布式意味着状态的定义可以放在任何位置，不必统一注册到一个文件中。

五、sso 单点流程

我们内部 sso 系统使用的是 Cookie 作为鉴权，需要设置 Cookie 的域为顶域。具体流程是：访问 A 系统，但是没有登录，于是携带当前 url 作为参数，跳转到 sso 系统去登录，登录完后，sso 会根据 url 参数，重定向回 A 系统，并携带一个 code 参数。A 系统需要把 code 发送给 A 系统的后端，让后端去请求 sso 服务，sso 服务校验 code 后，就会把 cookie 设置到顶域，并把 token 返回给 A 系统后端。后端再返回 A 系统前端代表校验通过，前端会刷新页面，把 url 的 code 参数清除掉。

六、工作中遇到的困难和挑战

1、有个页面要接入 PayPal 支付，在开发环境接入他们的支付组件时，偶尔会失败，排查原因后发现是他们组件内部发起的一个 js 文件偶尔会 502。因为是他们 sdk 内部问题，所以发邮件咨询了 paypal 官方，他们回复说确实存在该问题，但是短期内还没法解决。那怎么办呢，项目是要上线的，最后去看 sdk 源码是怎么请求 js 文件，自己在做了个兜底，主要方法是当检测到支付组件加载失败时，一直手动去尝试加载那个 js 文件，直到成功就再次加载组件，也算是曲线救国。

2、前端团队中的代码风格各式各样，使用的编辑器也不一样，有时候仅仅改了一行代码，但是因为格式化了，提交记录的改动是一大片内容，造成代码冲突，也不利于问题定位。要统一代码规范，设计方案与落地。需要兼容vue2、vue3差异。经过调研后，决定采用ESLint+Prettier进行代码规范校验与格式化。最大阻力是部分成员认为限制开发自由，也觉得麻烦，不愿意配置。后面亲自写成公共包、每个项目亲自配置，写实践记录，给不同的编辑器写配置指南。

七、如果让你设计一个高可维护的前端应用，会考虑哪些架构原则？

我会遵循以下原则：

分层架构：分离 UI 层（组件）、业务逻辑层（封装成 Hooks/Store）、数据层（请求 API 等）

模块化：通过微前端或 Monorepo 或者 npm 包 拆分功能模块，降低团队协作冲突。

状态管理：根据场景选择方案，简单场景用 Context API，复杂数据流用 Redux。

类型安全：全链路 TypeScript 覆盖，定义清晰的 DTO 和接口契约。

八、请分享一个你主导的技术方案，并说明当时的挑战和解决过程。

某个项目首屏加载缓慢。

问题定位：发现主因是未代码分割的巨型 Bundle（2MB+）和未压缩图片。

解决方案：

- 升级 webpack 版本与相关插件，替换过时插件。
- 使用 Webpack 动态导入（import() 语法）拆分路由级代码。
- 定义分包-optimization.splitChunks（使用 SplitChunksPlugin 来实现的）
- 使用 CDN：打包的所有静态资源，放到 CDN 服务器， 用户所有资源都是通过 CDN 服务器加载的；第三方库等资源放到 CDN 服务器上；
- 提取 css 到独立的文件（mini-css-extract-plugin）
- 打包文件命名(Hash,ContentHash,ChunkHash)，让浏览器使用缓存
- 压缩图片等资源

---

vue 和 react 对比

react 怎么提高效率

react fiber 调度任务的优先级

组件库怎么搭建

有没有什么提高效率的

模块化系统对比

代码分包策略

pnpm

typrescript

文件断点续传

为什么要refreshToken
一个完整的前端监控平台包括三个部分数据采集与上报，数据整理与存储，数量展示。

## 数据采集与上报

### 数据采集

- 错误监控：js错误，资源加载错误，自定义错误等
- 性能监控：首屏渲染时间、接口请求耗时、缓存命中率等
- 行为监控：UV、PV、用户点击、自定义事件等

### 数据上报

- 上报方式：image、ajax、sendBeacon
- 上报时机：requestIdleCallback/settimeout、beforeunload、达到缓存上限时上报

## 性能数据采集

通过`performanceObserve`来获取，它是个性能监控对象，用于检测性能度量事件

- FP(first-paint)：从页面加载开始到第一个像素绘制的时间，即是白屏时间
- FCP(first-contentful-paint)：从页面加载开始到页面的任何一个部分（文本、图形、svg或canvas等）在屏幕上完成渲染的时间。
- LCP(largest-contentful-paint)：从页面加载开始到最大的文本块或图形元素在屏幕上完成渲染的时间（考察的元素类型为：`<img>`、内嵌在`<svg>`的`<image>`、`<video>`、通过url加载背景图的元素、包含文本节点或其他行内级文本元素子元素的块级元）。


FCP与LCP的区别是FCP是任意内容完成绘制就触发，LCP是最大内容完成时触发。

```javascript
const entryHandler = (list) => {
  for(const entry of list.getEntries()) {
    if(entry.name === 'first-contentful-paint') {
      observe.disconnect()
    }
    console.log(entry)
    // {
    //   name: 'first-paint',
    //   duration: 0,
    //   entryType: 'paint',
    //   startTime: 359 // fp
    // }
    // {
    //   name: 'first-contentful-paint',
    //   duration: 0,
    //   entryType: 'paint',
    //   startTime: 459  // fcp
    // }
  }
}
const observer = new PerformanceObverser(entryHandler)
// buffered 属性表示是否观察缓存数据，即使添加观察的时机比事件触发的晚
observer.observe({ type: 'paint', buffered: true })
```

```javascript
const entryHandler = (list) => {
    if (observer) {
        observer.disconnect()
    }

    for (const entry of list.getEntries()) {
        console.log(entry)
    }
  //   {
  //     duration: 0,
  //     element: p,
  //     entryType: "largest-contentful-paint",
  //     id: "",
  //     loadTime: 0,
  //     name: "",
  //     renderTime: 1021.299,
  //     size: 37932,
  //     startTime: 1021.299,
  //     url: "",
  // }
}

const observer = new PerformanceObserver(entryHandler)
observer.observe({ type: 'largest-contentful-paint', buffered: true })
```

### 首屏渲染时间

大多数情况下，首屏渲染时间可以通过 load 事件获取。除了一些特殊情况，例如异步加载的图片和 DOM。这时我们需要通过 MutationObserver 来获取首屏渲染时间。MutationObserver 在监听的 DOM 元素属性发生变化时会触发事件。

- 使用`MutationObverser`监听document对象。
- 判断监听到的dom对象是否在首屏中，如果在，在`requestAnimationFrame`回调中调用`performance.now()`获取当前时间（因为当 DOM 变更触发 MutationObserver 事件时，只是代表 DOM 内容可以被读取到，并不代表该 DOM 被绘制到了屏幕上，所以使用 requestAnimationFrame 在浏览器绘制成功后再获取当前时间），作为 DOM 绘制时间。
- 将最晚的一个dom 元素的绘制时间和首屏所有图片的加载时间做对比，取最大值作为首屏渲染时间。

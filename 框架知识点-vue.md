### vue 列表的 key

key 在列表渲染中的作用是：在复杂的列表渲染中快速准确的找到与 newVnode 相对应的 oldVnode，提升 diff 效率。
vue 中使用 key 不一定能提提高 diff 效率。例如有个列表

```html
<!-- 初始 -->
<li>A</li>
<li>B</li>
<li>C</li>

<!-- 打乱顺序 -->
<li>C</li>
<li>A</li>
<li>C</li>
```

没有设置 key 时，vue 只需要更新 dom 的文本内容，如果给每个 li 设置了 key，vue 需要去对比新旧然后进行 dom 的移动、添加或删除，效率反而更低。

### vue模板编译过程

- 将模板字符串转化成AST
- 遍历AST标记静态节点：因为静态节点不需要总是重新渲染，这样在虚拟dom更新节点时，发现节点有标记就不需要重新渲染它。
- 将AST转化成render函数

这三部分内容在模板编译中分别抽象出三个模块实现各自的功能：解析器、优化器和代码生成器。


### vue3 性能提升点

#### diff 算法优化

vue3 在 diff 算法中相比 vue2 增加了静态标记。其作用是为了会发生变化的地方添加一个 flag 标记，下次发生变化的时候直接找该地方进行比较。标记为静态节点的节点在 diff 过程中则不会比较，把性能进一步提高。

#### 整体体积变小

移出了一些不常用的 api，支持 Tree shanking。任何一个函数，如 ref、computed 等，仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小。

#### 响应式系统

vue2 中采用 defineProperty 来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加 getter 和 setter，实现响应式。
vue3 采用 proxy 重写了响应式系统，因为 proxy 可以对整个对象进行监听，所以不需要遍历。

- 可以监听属性的添加和删除
- 可以监听到数组的索引和数组 length 属性

但是 proxy 仍无法监听深层次的嵌套对象，vue3的处理方式是在`getter`中递归响应式，这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归。